/*******************************************************************************
 * @file    timers.c
 * @brief   Has functions to set the LETIMER0 to generate interrupts with COMP0
 *          and COMP1 overflow. Also contains to generate required delay using
 *          COMP1 interrupts.
 *
 * @author  Ajay Kandagal, ajka9053@colorado.edu
 * @date    Nov 27, 2022
 *
 ******************************************************************************/
#include "em_letimer.h"
#include "em_cmu.h"

#include "timers.h"

#define INCLUDE_LOG_DEBUG 1
#include "src/log.h"


#define LETIMER_ON_TIME_MS    (0)
#define LETIMER_PERIOD_MS     (15000U)
#define LETIMER_TO_MS_FACTOR  (1000U)


/*******************************************************************************
 * Sets COMP1 and COMP0 of LETIMER0 to generate two interrupts at comp1_ms and
 * comp0_ms intervals respectively.
 * NOTE: comp1_ms should always be less than comp0_ms value.
 *
 * @param     comp1_ms    Value in milliseconds
 * @param     comp0_ms    Value in milliseconds
 *
 ******************************************************************************/
void init_LETIMER0(uint16_t comp1_ms, uint16_t comp0_ms)
{
  // Calculated COMP0 and COMP1 values for given LED ON TIME and LED PERIOD
  // are stored in comp0_counter and comp1_counter variables respectively

  uint16_t comp0_counter = 0;
  uint16_t comp1_counter = 0;

  comp0_counter = (comp0_ms * CMU_ClockFreqGet(cmuClock_LETIMER0)) / 1000;
  comp1_counter = (comp1_ms * CMU_ClockFreqGet(cmuClock_LETIMER0)) / 1000;

  const LETIMER_Init_TypeDef letimerInit =
      {
          .enable         = false,
          .debugRun       = true,
          .comp0Top       = false,
          .bufTop         = false,
          .out0Pol        = 0,
          .out1Pol        = 0,
          .ufoa0          = letimerUFOANone,
          .ufoa1          = letimerUFOANone,
          .repMode        = letimerRepeatFree,
          .topValue        = comp0_counter
      };



  if (comp0_counter && comp1_counter)
    {
      LETIMER_CompareSet(LETIMER0, 1 , comp1_counter);
      LETIMER_CompareSet(LETIMER0, 0 , comp0_counter);
      LETIMER_IntEnable(LETIMER0, LETIMER_IEN_UF | LETIMER_IEN_COMP1);
    }
  else if (comp0_counter) {
      LETIMER_CompareSet(LETIMER0, 0 , comp0_counter);
      LETIMER_IntEnable(LETIMER0, LETIMER_IEN_UF);
  }
  else {
      LETIMER_IntDisable(LETIMER0, LETIMER_IEN_UF | LETIMER_IEN_COMP1);
  }

  LETIMER_Init(LETIMER0, &letimerInit);

  LETIMER_Enable(LETIMER0, true);
}


/*******************************************************************************
 * This function creates mili-second delay using LETIMER0 COMP1 interrupt.
 *
 * @param     us_wait    Value in microseconds, to be generated by COMP1 OV
 *
 ******************************************************************************/
void timerWaitUs_irq(uint32_t us_wait)
{
  uint32_t ms_wait = us_wait / LETIMER_TO_MS_FACTOR;

  if(ms_wait > LETIMER_PERIOD_MS) {
      LOG_ERROR("Wait requested is outside range\n");
      return;
  }

  uint32_t elapsed_time = (LETIMER_CounterGet(LETIMER0) * LETIMER_TO_MS_FACTOR) /
      CMU_ClockFreqGet(cmuClock_LETIMER0);

  if (ms_wait > elapsed_time) {
      LOG_ERROR("Wait requested is outside range\n");
      return;
  }

  init_LETIMER0((elapsed_time - ms_wait), LETIMER_PERIOD_MS);
}
